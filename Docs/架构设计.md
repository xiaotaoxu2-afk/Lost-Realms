项目架构设计文档
1. 项目概述
项目名称：PixelAdventure（像素冒险）
项目类型：Unity 2D横版动作冒险游戏
开发周期：2025.9 - 2025.12（个人独立开发）
核心技术栈：Unity 2022.3 + C# + InputSystem + UGUI + Behavior Designer + Addressables + Physics2D + Cinemachine + DG.Tweening + Newtonsoft.Json
架构设计目标：低耦合、高可扩展，便于后续新增关卡、敌人类型；核心模块可复用

2. 核心模块划分
2.1 模块整体架构（分层设计）
采用「表现层-逻辑层-数据层」分层架构，减少模块间依赖：
表现层：负责UI显示、动画播放、音效输出（如UGUI组件、Animator、AudioSource）
逻辑层：负责核心游戏逻辑（角色控制、AI行为、战斗判定、场景管理）
数据层：负责数据存储与传递（如角色属性、场景配置、事件参数，基于ScriptableObject实现）
2.2 各模块详细设计
（1）角色控制系统
模块职责：处理玩家输入、实现角色移动/跳跃/攻击等交互逻辑
核心脚本：PlayerControl.cs、PlayerSkill.cs、PlayerAnim.cs
设计思路：
基于InputSystem实现输入监听，通过「输入动作映射」适配键盘/手柄双端输入（如WASD/左摇杆控制移动）；
分离「输入处理」与「逻辑执行」：InputSystem的回调函数仅传递输入状态，具体移动/攻击逻辑在PlayerControl中实现，降低耦合；
动画与逻辑同步：通过Animator参数（如isRun、isjumping、isAttack）控制动画播放，攻击判定通过动画关键帧事件触发（避免帧检测低效问题）。
（2）敌人AI系统
模块职责：实现普通敌人巡逻/追击、Boss多阶段战斗逻辑
核心脚本：Enemy.cs（敌人基类）、BaseState.cs（状态基类）、SlimePatrolState.cs（普通敌人巡逻状态）、BossController.cs、BossAI.cs、BossAnimEvents.cs
设计思路：
普通敌人：采用「状态机模式」，抽象Enemy基类，子类实现具体状态（巡逻、追击、攻击），通过状态切换函数（stateSwitch）实现平滑过渡；
Boss敌人：基于Behavior Designer搭建行为树，结合状态机模式，实现「巡逻→仇恨触发→三段连击→跳砸AOE→受伤硬直」复杂逻辑；
状态优先级机制：受伤状态优先级最高，可中断普通攻击/巡逻状态，避免逻辑冲突。
（3）资源管理系统
模块职责：实现场景、预制体、音效等资源的异步加载与内存优化
核心脚本：SceneLoader.cs、InitialLoad.cs
设计思路：
基于Addressables实现资源分组管理（场景组、角色预制体组），支持异步加载与自动释放；
场景加载封装：通过SceneLoader.cs统一处理场景加载流程（玩家位置初始化、屏幕渐入渐出过渡）；
（4）事件通信系统
模块职责：解决跨模块通信问题（如场景加载请求、音效播放请求），降低模块耦合
核心脚本：SceneLoadEventSO.cs、PlayerAudioEventSO.cs（基于ScriptableObject）
设计思路：
采用「事件驱动模式」，通过ScriptableObject定义事件（如SceneLoadEvent包含目标场景名、玩家出生点坐标参数）；
订阅-发布机制：需要响应事件的模块（如SceneLoader）订阅事件，触发事件的模块（如场景切换触发点）仅需调用RaiseEvent方法，无需直接引用接收模块；
（5）UI系统
模块职责：实现主菜单、战斗HUD（血条、能量条）、结算界面等交互
核心脚本：UIManager.cs、PlayerStatBar.cs、Menu.cs
设计思路：
单例模式管理UI：UIManager作为UI总入口，统一控制各面板的显示/隐藏，避免多脚本直接操作UI组件；
数据驱动UI：角色血条、能量条通过监听角色属性变化事件（如OnHealthChange）更新，无需UI脚本主动查询数据；
自适应适配：基础适配1080P/720P分辨率，通过UGUI锚点设置保证核心UI元素不偏移。

3. 模块间交互逻辑
以「玩家触发场景切换」为例，说明模块间交互：
玩家碰撞场景切换触发点（Trigger），触发Teleport.cs的OnTiggerAction方法；
Teleport通过SceneLoadEventSO.RaiseLoadRequestEvent方法，发布场景加载请求（传递目标场景名、玩家出生点坐标）；
SceneLoader.cs（已订阅SceneLoadEventSO事件）接收请求，调用Addressables.LoadSceneAsync加载目标场景；
场景加载完成后，SceneLoader通过afterSceneLoadEvent发布玩家生成事件，PlayerControl接收事件并在指定位置生成玩家；
UIManager接收场景加载完成事件，显示新场景的UI面板。

4. 可扩展设计说明
敌人扩展：新增敌人时，可继承Enemy基类，实现自定义状态（如飞行敌人的悬浮状态），无需修改现有框架；
技能扩展：角色新增技能时，可扩展PlayerSkill.cs脚本，通过InputSystem新增技能输入动作，调用技能逻辑，不影响现有移动/攻击逻辑；
关卡扩展：通过Addressables新增关卡资源组，配置GameSceneSO的参数即可实现新关卡切换，无需修改加载逻辑。

